using System;
using System.Buffers.Binary;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;
using JetBrains.Annotations;

#pragma warning disable CS1574 // XML comment has cref attribute that could not be resolved
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

namespace NexusMods.Hashing.xxHash64;

/// <summary>
///     Named object for an individual hash.
/// </summary>
/// <remarks>
///     This is Vogen generated code, but we copied it and removed the Initialized and Stack Trace fields,
///     since we require this to be 8 bytes in size.
/// </remarks>
[PublicAPI]
[ExcludeFromCodeCoverage]
[GeneratedCode("Vogen", "3.0.0.0")]
[JsonConverter(typeof(HashSystemTextJsonConverter))]
[TypeConverter(typeof(HashTypeConverter))]
[DebuggerDisplay("Underlying type: System.UInt64, Value = { Value }")]
public readonly struct Hash : IEquatable<Hash>, IEquatable<ulong>, IComparable<Hash>, IComparable
{
    /// <summary>
    ///     Gets the underlying <see cref="System.UInt64" /> value if set, otherwise a
    ///     <see cref="ValueObjectValidationException" /> is thrown.
    /// </summary>
    public ulong Value { [DebuggerStepThrough] get; }

    /// <summary>
    ///     Represents a default [zero] value for the hash.
    ///     Used for when the value is not set.
    /// </summary>
    public static readonly Hash Zero = From(0);

    /// <inheritdoc />
    public override string ToString()
    {
        return "0x" + ToHex();
    }

    /// <summary>
    ///     Creates a hash from a long [8 byte] value.
    /// </summary>
    /// <param name="argHash">The hash to use.</param>
    public static Hash FromLong(in long argHash)
    {
        return From(unchecked((ulong)argHash));
    }

    /// <summary>
    ///     Creates a hash from a ulong [8 byte] value.
    /// </summary>
    /// <param name="argHash">The hash to use.</param>
    public static Hash FromULong(in ulong argHash)
    {
        return From(argHash);
    }

    /// <summary>
    ///     Converts hash from a hexadecimal string representation back into value.
    /// </summary>
    /// <param name="hash">The hash to convert.</param>
    public static Hash FromHex(string hash)
    {
        Span<byte> bytes = stackalloc byte[8];
        hash.FromHex(bytes);
        return From(BinaryPrimitives.ReadUInt64BigEndian(bytes));
    }

    /// <summary>
    ///     Converts hash to hexadecimal string.
    /// </summary>
    public string ToHex()
    {
        Span<byte> buffer = stackalloc byte[8];
        BinaryPrimitives.WriteUInt64BigEndian(buffer, Value);
        return ((ReadOnlySpan<byte>)buffer).ToHex();
    }

    /// <summary>
    ///     Converts a hash back to a long.
    /// </summary>
    public static implicit operator long(Hash a)
    {
        return unchecked((long)a.Value);
    }


    #region Autogenerated by Vogen

    [DebuggerStepThrough]
    [EditorBrowsable(EditorBrowsableState.Never)]
    public Hash()
    {
        Value = default;
    }

    [DebuggerStepThrough]
    private Hash(ulong value)
    {
        Value = value;
    }

    /// <summary>
    ///     Builds an instance from the provided underlying type.
    /// </summary>
    /// <param name="value">The underlying type.</param>
    /// <returns>An instance of this type.</returns>
    public static Hash From(ulong value)
    {
        var instance = new Hash(value);
        return instance;
    }

    public static explicit operator Hash(ulong value)
    {
        return From(value);
    }

    public static explicit operator ulong(Hash value)
    {
        return value.Value;
    }

    // only called internally when something has been deserialized into
    // its primitive type.
    private static Hash Deserialize(ulong value)
    {
        return new Hash(value);
    }

    public readonly bool Equals(Hash other)
    {
        return EqualityComparer<ulong>.Default.Equals(Value, other.Value);
    }

    public readonly bool Equals(ulong primitive)
    {
        return Value.Equals(primitive);
    }

    public readonly override bool Equals(object? obj)
    {
        return obj is Hash && Equals((Hash)obj);
    }

    public static bool operator ==(Hash left, Hash right)
    {
        return Equals(left, right);
    }

    public static bool operator !=(Hash left, Hash right)
    {
        return !(left == right);
    }

    public static bool operator ==(Hash left, ulong right)
    {
        return Equals(left.Value, right);
    }

    public static bool operator !=(Hash left, ulong right)
    {
        return !Equals(left.Value, right);
    }

    public static bool operator ==(ulong left, Hash right)
    {
        return Equals(left, right.Value);
    }

    public static bool operator !=(ulong left, Hash right)
    {
        return !Equals(left, right.Value);
    }

    public int CompareTo(Hash other)
    {
        return Value.CompareTo(other.Value);
    }

    public int CompareTo(object? other)
    {
        if (other == null) return 1;
        if (other is Hash x) return CompareTo(x);
        throw new ArgumentException("Cannot compare to object as it is not of type Hash", nameof(other));
    }


    /// <inheritdoc
    ///     cref="ulong.TryParse(System.ReadOnlySpan{char}, System.Globalization.NumberStyles, System.IFormatProvider?, out ulong)" />
    /// <summary>
    /// </summary>
    /// <returns>
    ///     The value created via the <see cref="From" /> method.
    /// </returns>
    /// <exception cref="ValueObjectValidationException">Thrown when the value can be parsed, but is not valid.</exception>
    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider,
        out Hash result)
    {
#if NETSTANDARD2_0
        if (ulong.TryParse(s.ToString(), NumberStyles.Integer, provider, out var r))
        {
            result = From(r);
            return true;
        }
#else
        if (ulong.TryParse(s, NumberStyles.Integer, provider, out var r))
        {
            result = From(r);
            return true;
        }
#endif

        result = default;
        return false;
    }

    /// <inheritdoc cref="ulong.TryParse(System.ReadOnlySpan{char}, System.IFormatProvider?, out ulong)" />
    /// <summary>
    /// </summary>
    /// <returns>
    ///     The value created via the <see cref="From" /> method.
    /// </returns>
    /// <exception cref="ValueObjectValidationException">Thrown when the value can be parsed, but is not valid.</exception>
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider provider,
        out Hash result)
    {
#if NETSTANDARD2_0
        if (ulong.TryParse(s.ToString(), NumberStyles.Integer, provider, out var r))
        {
            result = From(r);
            return true;
        }
#else
        if (ulong.TryParse(s, NumberStyles.Integer, provider, out var r))
        {
            result = From(r);
            return true;
        }
#endif

        result = default;
        return false;
    }

    /// <inheritdoc cref="ulong.TryParse(System.ReadOnlySpan{char}, out ulong)" />
    /// <summary>
    /// </summary>
    /// <returns>
    ///     The value created via the <see cref="From" /> method.
    /// </returns>
    /// <exception cref="ValueObjectValidationException">Thrown when the value can be parsed, but is not valid.</exception>
    public static bool TryParse(ReadOnlySpan<char> s,
        out Hash result)
    {

#if NETSTANDARD2_0
        if (ulong.TryParse(s.ToString(), out var r))
        {
            result = From(r);
            return true;
        }
#else
        if (ulong.TryParse(s, out var r))
        {
            result = From(r);
            return true;
        }
#endif

        result = default;
        return false;
    }

    /// <inheritdoc cref="ulong.TryParse(string?, System.Globalization.NumberStyles, System.IFormatProvider?, out ulong)" />
    /// <summary>
    /// </summary>
    /// <returns>
    ///     The value created via the <see cref="From" /> method.
    /// </returns>
    /// <exception cref="ValueObjectValidationException">Thrown when the value can be parsed, but is not valid.</exception>
    public static bool TryParse(string s, NumberStyles style, IFormatProvider provider,
#if NETCOREAPP3_0_OR_GREATER
#endif
        out Hash result)
    {
        if (ulong.TryParse(s, style, provider, out var r))
        {
            result = From(r);
            return true;
        }

        result = default;
        return false;
    }

    /// <inheritdoc cref="ulong.TryParse(string?, System.IFormatProvider?, out ulong)" />
    /// <summary>
    /// </summary>
    /// <returns>
    ///     The value created via the <see cref="From" /> method.
    /// </returns>
    /// <exception cref="ValueObjectValidationException">Thrown when the value can be parsed, but is not valid.</exception>
    public static bool TryParse(string s, IFormatProvider provider, out Hash result)
    {
        if (ulong.TryParse(s, NumberStyles.Integer, provider, out var r))
        {
            result = From(r);
            return true;
        }

        result = default;
        return false;
    }

    /// <inheritdoc cref="ulong.TryParse(string?, out ulong)" />
    /// <summary>
    /// </summary>
    /// <returns>
    ///     The value created via the <see cref="From" /> method.
    /// </returns>
    /// <exception cref="ValueObjectValidationException">Thrown when the value can be parsed, but is not valid.</exception>
    public static bool TryParse(string s, out Hash result)
    {
        if (ulong.TryParse(s, out var r))
        {
            result = From(r);
            return true;
        }

        result = default;
        return false;
    }


    public readonly override int GetHashCode()
    {
        return EqualityComparer<ulong>.Default.GetHashCode(Value);
    }

    private class HashSystemTextJsonConverter : JsonConverter<Hash>
    {
        public override Hash Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
        {
            var primitive = JsonSerializer.Deserialize<ulong>(ref reader, options);
            return Deserialize(primitive);
        }

        public override void Write(Utf8JsonWriter writer, Hash value, JsonSerializerOptions options)
        {
            JsonSerializer.Serialize(writer, value.Value);
        }

#if NET6_0_OR_GREATER
        public override Hash ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert,
            JsonSerializerOptions options)
        {
            var primitive = JsonSerializer.Deserialize<ulong>(ref reader, options);
            return Deserialize(primitive);
        }

        public override void WriteAsPropertyName(Utf8JsonWriter writer, Hash value, JsonSerializerOptions options)
        {
            writer.WritePropertyName(JsonSerializer.Serialize(value.Value));
        }
#endif
    }

    private class HashTypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType)
        {
            return sourceType == typeof(ulong);
        }

        public override object ConvertFrom(ITypeDescriptorContext? context, CultureInfo? culture, object? value)
        {
            var ut = (ulong)value!;
            return Deserialize(ut);
        }

        public override bool CanConvertTo(ITypeDescriptorContext? context, Type? sourceType)
        {
            return sourceType == typeof(ulong);
        }

        public override object ConvertTo(ITypeDescriptorContext? context, CultureInfo? culture, object? value,
            Type destinationType)
        {
            if (value is Hash idValue) return idValue.Value;
            return base.ConvertTo(context, culture, value, destinationType)!;
        }
    }

    #endregion
}
